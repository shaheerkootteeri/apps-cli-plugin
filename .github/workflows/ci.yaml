name: CI

on:
  push: 
    branches:
    - '**'
    - '!dependabot/**'
    tags:
    - '**'
  pull_request: {}

jobs:

  unitubuntu:
    env:
      TKG_CUSTOM_IMAGE_REPOSITORY: projects-stg.registry.vmware.com/tkg
      TANZU_CLI_NO_INIT: true
      TANZU_HOME: $HOME/tanzu
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-go@v3
      with:
        go-version: 1.19.x
    - name: Grype scan
      run: |
        echo "##[group]Install grype"
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin
        echo "##[endgroup]"
        echo "##[group]Scan source ."
          grype dir:. --exclude ./hack,./vendor --exclude '**/testdata/**'
          


    - name: Install tanzu cli
      run: |
        TANZU_VERSION=$(cat TANZU_VERSION)
        env
        mkdir -p ${TANZU_HOME}
        curl -Lo tanzu-framework.tar.gz https://github.com/vmware-tanzu/tanzu-framework/releases/download/${TANZU_VERSION}/tanzu-framework-linux-amd64.tar.gz
        tar -xzf tanzu-framework.tar.gz -C ${TANZU_HOME}
        sudo mv ${TANZU_HOME}/cli/core/${TANZU_VERSION}/tanzu-core-linux_amd64 /usr/local/bin/tanzu
        chmod +x /usr/local/bin/tanzu
        tanzu init
        tanzu plugin repo add -b tanzu-cli-admin-plugins -n admin -p artifacts-admin
        curl -Lo admin-plugins.tar.gz https://github.com/vmware-tanzu/tanzu-framework/releases/download/${TANZU_VERSION}/tanzu-framework-plugins-admin-linux-amd64.tar.gz
        tar -xzf admin-plugins.tar.gz -C ${TANZU_HOME}
        tanzu plugin install builder --local ${TANZU_HOME}/admin-plugins
        tanzu builder version
        tanzu plugin install test --local ${TANZU_HOME}/admin-plugins
        tanzu plugin list
    - name: Test
      run: make test
    - name: Build Version
      run: echo "BUILD_VERSION=${GITHUB_REF/refs\/tags\//}" >> $GITHUB_ENV
      if: startsWith(github.ref, 'refs/tags/')
    - name: Build
      run: |
        make publish
    - uses: actions/upload-artifact@v3
      with:
        name: tanzu-apps-plugin.tar.gz
        path: tanzu-apps-plugin*.tar.gz
        retention-days: 1
    - name: Install
      run: make install
    - name: Verify docs
      run: |
        rm -rf docs/command-reference
        tanzu apps docs --directory docs/command-reference
        git diff --exit-code docs
      continue-on-error: true

  setupCluster:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        k8s:
        - 1.23.5
    env:
      REGISTRY_NAME: registry.local
      REGISTRY_USERNAME: ruser
      REGISTRY_PASSWORD: rpass
      BUNDLE: registry.local/integration-test/hellojar:source
      TANZU_CLI_NO_INIT: true
      TANZU_HOME: $HOME/tanzu
      OS_ARCH: linux-amd64
      TKG_CUSTOM_IMAGE_REPOSITORY: projects-stg.registry.vmware.com/tkg
    steps:
    - uses: actions/checkout@v3
    - uses: vmware-tanzu/carvel-setup-action@v1
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    - uses: actions/setup-go@v3
      with:
        go-version: 1.19.x
    - name: setup DNS
      run: |
        ping google.com
        ping 8.8.8.8


    - name: Generate certs
      run: |
        set -o errexit
        set -o nounset
        set -o pipefail
        CERT_DIR=$(mktemp -d -t certs.XXXX)
        echo "CERT_DIR=$CERT_DIR" >> $GITHUB_ENV
        echo "##[group]Install cfssl"
          go install github.com/cloudflare/cfssl/cmd/cfssl@v1.6.2
          go install github.com/cloudflare/cfssl/cmd/cfssljson@v1.6.2
        echo "##[endgroup]"
        echo "##[group]Generate CA"
          cfssl gencert -initca ./.github/tls/root-csr.json \
            | cfssljson -bare ${CERT_DIR}/root-ca
          cfssl gencert -ca ${CERT_DIR}/root-ca.pem -ca-key ${CERT_DIR}/root-ca-key.pem \
            -config=".github/tls/config.json" \
            -profile="intermediate" ./.github/tls/intermediate-csr.json \
            | cfssljson -bare ${CERT_DIR}/signing-ca
          cat ${CERT_DIR}/signing-ca.pem ${CERT_DIR}/root-ca.pem > ${CERT_DIR}/ca.pem
        echo "##[endgroup]"
        echo "##[group]Install CA"
          # https://ubuntu.com/server/docs/security-trust-store
          sudo apt-get install -y ca-certificates
        echo "##[endgroup]"
        echo "##[group]Generate cert"
          cfssl gencert -ca ${CERT_DIR}/signing-ca.pem -ca-key ${CERT_DIR}/signing-ca-key.pem \
            -config=".github/tls/config.json" \
            -profile="server" \
            -hostname="${REGISTRY_NAME},local-registry" \
            .github/tls/server-csr.json \
            | cfssljson -bare ${CERT_DIR}/server
        echo "##[endgroup]"
    - name: Setup local registry
      run: |
        set -o errexit
        set -o nounset
        set -o pipefail
        # Create password file
        REGISTRY_HTPWD=$(mktemp -d -t htpwd.XXXX)
        docker run \
        --entrypoint htpasswd --platform=linux \
        httpd:2 -Bbn ${REGISTRY_USERNAME} ${REGISTRY_PASSWORD} > ${REGISTRY_HTPWD}/htpasswd
        
        # Run a registry.
        docker run -d \
          --restart=always \
          --name local-registry \
          -v ${CERT_DIR}:/certs \
          -e REGISTRY_HTTP_ADDR=0.0.0.0:443 \
          -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/server.pem \
          -e REGISTRY_HTTP_TLS_KEY=/certs/server-key.pem \
          -p "443:443" \
          registry:2
        # Make the $REGISTRY_NAME -> local-registry
        echo "$(hostname -I | cut -d' ' -f1) $REGISTRY_NAME" | sudo tee -a /etc/hosts
    - name: Install kind
      run: |
        cd $(mktemp -d -t kind.XXXX)
        curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.11.1/kind-$(go env GOHOSTOS)-$(go env GOHOSTARCH)
        chmod +x ./kind
        sudo mv ./kind /usr/local/bin
        cd -
    - name: create cluster
      id: cluster
      run: |
        set -o errexit
        set -o nounset
        set -o pipefail
     
        # KinD configuration.
        # create a cluster with the local registry enabled in containerd
        cat <<EOF | kind create cluster --config=-
        kind: Cluster
        apiVersion: kind.x-k8s.io/v1alpha4
        containerdConfigPatches:
        - |-
          [plugins."io.containerd.grpc.v1.cri".registry.mirrors."${REGISTRY_NAME}"]
            endpoint = ["https://local-registry"]
        - |-
          [plugins."io.containerd.grpc.v1.cri".registry.configs."local-registry".tls]
            ca_file  = "/etc/docker/certs.d/local-registry/ca.pem"
        nodes:
        - role: control-plane
          image: kindest/node:v${{ matrix.k8s }}
          extraMounts:
          - containerPath: /etc/docker/certs.d/local-registry
            hostPath: ${CERT_DIR}
        EOF

        # connect the registry to the cluster network
        docker network connect kind local-registry

        # Document the local registry
        # https://github.com/kubernetes/enhancements/tree/master/keps/sig-cluster-lifecycle/generic/1755-communicating-a-local-registry
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: local-registry-hosting
          namespace: kube-public
        data:
          localRegistryHosting.v1: |
            host: "localhost"
            help: "https://kind.sigs.k8s.io/docs/user/local-registry/"
        EOF
        kubectl cluster-info 
        ifconfig
        export ipaddress=$(ifconfig eth0 | grep "inet\b" | cut -d/ -f1 | awk '{ print $2}')
        echo $ipaddress
        config=$( cat $HOME/.kube/config )
        # localhost=grep 'server: ' $HOME/.kube/config | cut -d\   -f3
        # echo $config
        sudo ufw status
        sudo ufw disable
        sudo ufw status

        echo "::set-output name=ipaddress::$ipaddress"
        echo "::set-output name=config::$config"
    - name: Deploy Cartographer
      run: |
        set -o errexit
        set -o nounset
        set -o pipefail
        
        echo "##[group]Apply cartographer"
          kubectl create namespace cartographer-system
          kapp deploy -y -a cartographer -n kube-system -f ./acceptance/vendor/cartographer/
        echo "##[endgroup]"
    - name: Sleep for 30 seconds
      run: sleep 120s
      shell: bash
    outputs:
      ipaddress: ${{ steps.cluster.outputs.ipaddress }}
      config: ${{ steps.cluster.outputs.config }}

  acceptancewindows1:
    env:
      TKG_CUSTOM_IMAGE_REPOSITORY: projects-stg.registry.vmware.com/tkg
      TANZU_CLI_NO_INIT: true
      TANZU_HOME: $HOME/tanzu
    runs-on: windows-latest
    needs: setupCluster
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-go@v3
      with:
        go-version: 1.19.x
 
    - name: output
      run: |
        echo ${{ needs.setupCluster.outputs.ipaddress }}
        echo ${{ needs.setupCluster.outputs.config }}
        ipconfig /flushdns
        netsh winsock reset
        netsh int ip reset
        netsh int ipv6 reset
        netsh int ipv4 reset 
        ping ${{ needs.setupCluster.outputs.ipaddress }}
        ping -6 ${{ needs.setupCluster.outputs.ipaddress }}
        tracert -6 -d ${{ needs.setupCluster.outputs.ipaddress }}
        ping 127.0.0.1
        ping 8.8.8.8
        ping google.com
        netsh advfirewall show all
        Set-NetFirewallProfile -Enabled False
        netsh advfirewall show all
        ping ${{ needs.setupCluster.outputs.ipaddress }}
        ping 127.0.0.1
        ping 8.8.8.8
        ping google.com
       
        mkdir ~/.kube
        $https="https://"
        $IP="${{ needs.setupCluster.outputs.ipaddress }}"
        $PORT=":33473"
        $config=@"
        apiVersion: v1 
        clusters: 
        - cluster: 
            certificate-authority-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUMvakNDQWVhZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQkFRc0ZBREFWTVJNd0VRWURWUVFERXdwcmRXSmwKY201bGRHVnpNQjRYRFRJeU1UQXhNVEU1TlRnd01Gb1hEVE15TVRBd09ERTVOVGd3TUZvd0ZURVRNQkVHQTFVRQpBeE1LYTNWaVpYSnVaWFJsY3pDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBS2lRCmxsdGRNMzNpMUVLMzA0bFREb25BWDBiQWpKbk15ZFl4eXFmbjNqOEh6Sm81MHVhcVRsTkY4UWVaeENEbjY5R24Ka2I5MTQ3aGFqS2xvY0VvMTVSSGhFUEJ1UDdpZ0NkQzhsRVVmMWluM3FKdkE1RzM4TGg5Z2dJNFRWZ0VTWDBEZwpuMGVWNG5wNDV1T3doRlI2MjRFNnk2Y3k3ZjJqdlQ3N3o4bUhWVitWVEJqWlhJQkpFSlFuamg5NWNybk9UdEJ6Cm1Ga1pYdEFuWThPMkVEQ0F1OTBqNkkyZWwwdzJycSt2NndqbitJd1d2NkFqNUVuY1ljdGphYWExMmtSZWNLYnQKdE8zM2pSNzhJelBUVnhoblorZ1lrdmV0QjRpcjJXbUVKUVhRNXkxdXBrMzI5L1NqUzJjNEFyRVFNWk9MRldvdwpSRWt0MDg1NzJNancrR2xmUWlzQ0F3RUFBYU5aTUZjd0RnWURWUjBQQVFIL0JBUURBZ0trTUE4R0ExVWRFd0VCCi93UUZNQU1CQWY4d0hRWURWUjBPQkJZRUZJWjRnS29HRjd5aXNpYlVNVnl0T2lncmZOTWJNQlVHQTFVZEVRUU8KTUF5Q0NtdDFZbVZ5Ym1WMFpYTXdEUVlKS29aSWh2Y05BUUVMQlFBRGdnRUJBSmdxdVZyc3hJRDNrWHZDeDZrawpKek1pejIvdnAyTUwvK1RzYTMzemdQU0FkVUF5RVVmbWJaRGZqUFJRa0NkWWZid0sxS056Wlpwc21FYURjVDQ0Cm9oMU1TTEVISDViaWFyTU9vOGZaY0hWYW1LR0FIYmtFQTR5emtvSVlMbWZvRis3MGJKTGhIOXMrZWV4OWpmZloKOEhncmtaOFRFdkptOFZuelZ6dVR0N0lvQzlVZWExTGV4VnFjcEp1S0Y2S0xxblBNM2V1TUc1U1J0WXhsYVpPMgpMMUNWOVEyMDJiWnNweU83YXJWdm5QK1dqckptcEZTR3IyQVF1a0toZEhwc1o0c0FleXprZ20rMWQycHNmRWR1CkZkYWx3WlR3WHd6M1BkR3dYK3ljR0J4UmsvZ29wcXIxOWQrYW9Fd1ZlL1BoeUVtYUh4ZTBFTU5CU3N3WnBkdkMKR1AwPQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg== 
            server: "$https$IP$PORT" 
          name: kind-kind 
        contexts: 
        - context: 
            cluster: kind-kind 
            user: kind-kind 
          name: kind-kind 
        current-context: kind-kind 
        kind: Config 
        preferences: {} 
        users: 
        - name: kind-kind 
          user: 
            client-certificate-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURJVENDQWdtZ0F3SUJBZ0lJR1crMlVrQ3VQNXd3RFFZSktvWklodmNOQVFFTEJRQXdGVEVUTUJFR0ExVUUKQXhNS2EzVmlaWEp1WlhSbGN6QWVGdzB5TWpFd01URXhPVFU0TURCYUZ3MHlNekV3TVRFeE9UVTRNRE5hTURReApGekFWQmdOVkJBb1REbk41YzNSbGJUcHRZWE4wWlhKek1Sa3dGd1lEVlFRREV4QnJkV0psY201bGRHVnpMV0ZrCmJXbHVNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQTAyT2JBWW5Tc2RieVkybWgKN2VBOVZxY1hTYW90THczWDBMOUptWUhuMXArdDVES2ZIYXBJRDNmRGdmbVNZWTBCQzEyWWQ4d1J4b1JqQVMwcgo4L2xHMy9ESWhINjd5SW14bkxlR0g4SkhxUzV1aU9xYlQ5UkthZkp0UTBPWmtieFpIZFlGSHVRaDdsVXo4cjJTCmlrMzZqaEhmMXl3RnloT2tycVN6dTZldnVXTUpJaXZrL25TWkFXKytaQkY0OWVTTGN4R3FUZjhYMytxMmJuazYKbGczaU1nMkQ4NG05bjlidERKZEJBZVVxWU1HQlptSmdYZUFGc0pHSXQ4alhHTmlPZUNEalZIcnRmSlMxUkZibgoxd2lyZ083YzllKzZBamZxbSttRVVKTGhSbzNZYXJxcFNQUE9oWVhkd2VCMjBLL005bHJhV0YrNkJXbVR4N0t5CjU3VTY3UUlEQVFBQm8xWXdWREFPQmdOVkhROEJBZjhFQkFNQ0JhQXdFd1lEVlIwbEJBd3dDZ1lJS3dZQkJRVUgKQXdJd0RBWURWUjBUQVFIL0JBSXdBREFmQmdOVkhTTUVHREFXZ0JTR2VJQ3FCaGU4b3JJbTFERmNyVG9vSzN6VApHekFOQmdrcWhraUc5dzBCQVFzRkFBT0NBUUVBajk5a1FBOWpVZGJ5MHdlWDVxcld4Z0E2OG16QS8vSkV2eG1xCmhuTWdIQjMxSSt4aTFBa1VlbStIOFRGVkVTc1dlbTlybVNtNnE1OW04N05iQXJyQ1JnVWsza0NSWTBRNFBhc3MKeVRSRUwrSiswbFB4aHJkLzVkL1p0ZmJGUDA4MXlpRkxmQW9STXNTeGxSOUZYNG1Id3BLbzJrNU9GUGNJZzByMQpLdTMrZHZtZGF0cTVLVkVCcnhZOTU4RSs5QTB6cXJGUUlsVkl5cGcwb2p3UGxlNm5EdGZLVDBjWXp4b0NFNHlGClkwY3JLNE5VOHhnQnZQTFd1ejZoVWZLQndJK1RuUFh5bzNjSzN5UXJoYzVKcjNmaWxvdTNZNzhiMjIxN3FPbnMKd1M5eXNJdVlRNzVhT2M2TXRZN2lmLzQzUjluQ3lRYlhDMzVKSCt3VlNZZ3VNdU5sbkE9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg== 
            client-key-data: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcFFJQkFBS0NBUUVBMDJPYkFZblNzZGJ5WTJtaDdlQTlWcWNYU2FvdEx3M1gwTDlKbVlIbjFwK3Q1REtmCkhhcElEM2ZEZ2ZtU1lZMEJDMTJZZDh3UnhvUmpBUzByOC9sRzMvREloSDY3eUlteG5MZUdIOEpIcVM1dWlPcWIKVDlSS2FmSnRRME9aa2J4WkhkWUZIdVFoN2xVejhyMlNpazM2amhIZjF5d0Z5aE9rcnFTenU2ZXZ1V01KSWl2awovblNaQVcrK1pCRjQ5ZVNMY3hHcVRmOFgzK3EyYm5rNmxnM2lNZzJEODRtOW45YnRESmRCQWVVcVlNR0JabUpnClhlQUZzSkdJdDhqWEdOaU9lQ0RqVkhydGZKUzFSRmJuMXdpcmdPN2M5ZSs2QWpmcW0rbUVVSkxoUm8zWWFycXAKU1BQT2hZWGR3ZUIyMEsvTTlscmFXRis2QldtVHg3S3k1N1U2N1FJREFRQUJBb0lCQVFDWVFMNnRUZnB1VXRZRQpXbG5pUGtlUHVRdWg2Q3RoSDhSWXV0NGs3WmJ4VTlOb2NEbUFvVndEb0F3MSttNi9TbEw5UDYySVkzaE9GcDVFCmc2ZUxzdmlrWlFYWHdIdzZSVXFqQ09CVzBaVFJ1dnFzTE9ZdWlrWUtweXloYlBnWUtxTzVSS1F0aXIwUnIxYWEKT0lacWpSMnc1QmpvSHZJUWlUTnRBbjNkNURwQitFNGMzNHdrOERVcDhadXFLVmtSK1RSL1FnTVNPOWhxSVBOSgpjb2dLTjg4WGVkbkZjWXBKRm4xY29LTjBkdTlhQkZKdUNjdS9uYUhhNUlUc2tkKzdUOGJtNVBQUE9Ba1NTMzQyCkJYZkZBNkNobnE1d0g1cDh1aVVBR2g0RllaRUJHaGordUR4K2Q1aVU0OGE5TFZnYzdzUHB3T3hYOGZ1OC9vZlcKelBiY1AvRzFBb0dCQU5wUWV0L1VTai82TUJaKzgxVjZuVk8ySlNicGxwRkg2UXNtbkFHSHV3S3A2RCtid0YxaApiZ2pnd2Jwblo3YlhtQi9JblZZT1lQR0FpNVg4RmxvRzFmRE1tbFFLV0ZJMkNJNCtoV0d0d2cwR05FUE9TOXJoCno1T3FLTldydkhGYmlDK0NZLzhVSUpoNEtZYjBZVEJta1FUWWhiQTJWdEZOKzF3L1ZRdGwvcEwzQW9HQkFQZmgKRng3bXhjVkRFSHhCRjhQT1R3ZS8xc0llSkxWUG1qUjFKK091c2FxMDNmc011YTA5Mk0rczlaMlNLYnlvMTJZbAo5ZUpwOUh5MXFndGtrUFJDVWFlM1JnRzlBNThGZHJ1Vks4d2tXQVpOcDBrSDVETlJRZ3Z0UUNoK2FPZUlWOVEyCjIyYXFSZnNFR2QzZDcxdkt3VGZqd1NtaEdQVmtIdGRYZkdhOVRvUTdBb0dCQUpJNWhaT1dKWVZrbGdEN1Z4RFIKNTc3Q0tYQSsxTkxLVDVWZ2J1MjNjOUw4NnNwd0VCQjd5YSs0bXdtM2FRaFdyMVhha1VlcXFkUVlQV1pnU3JoUwpDOG9Wd09pNVpSN3JnaCtFVU9Kejk1MnhvaUFvZFRaT09USzJybE12akRDQkZsNTcvMjVDbFBLS3lZWFMrYVhwCmpRaXAzaUdBdy9XOVBiY3oxRXFtTGpWUkFvR0JBSWN0dllvZ2wrSUh2TW5HUmN1R2l4clN4Njk4K00vWDVXU08KTDM2L0dpemFEZVNIQUFzMkd6TEdRL3YyWmNSNDMxN1pmTXBJdGdmOG1nczBnTWgwRWt2QWF2RXZ2dlhONlA1TApUMk00dnJoUlNOVk85R2YzL0dpOHJheG5vNVlBaU1VMlZWZ2JxNlpFaWthd2JZUkZnakdVaHhiSXYrK3k5ZzdCCnF4bnNTeEZaQW9HQWFFTWpIQ2xCTTN4WjRHVThoNlg2U2p3UzNtZS9IcGswckQwQmJsMjVzOGZlakZuQndKSWkKUk9oWUlZYVZIRjFiV3BHaTc1Q3I5R3ZOem5aTERoMC90UytSaGF1dFpzeWVZWHIvZ0RCTzdyNDVKZkpSc0Q1ZQpqRmFkU1NKeFp1UTlxOVdZVGZnQWJOYVNvcHBoSjFkNnVzalNvN2VKd0FqbDQzOEhCQkpDMUJvPQotLS0tLUVORCBSU0EgUFJJVkFURSBLRVktLS0tLQo=
        "@

        New-Item ~\.kube\config -ItemType File -Value $config

    - name: Grype scan
      run: |
        bash -c '
        echo "##[group]Install grype"
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin
        echo "##[endgroup]"
        echo "##[group]Scan source ."
          grype dir:. --exclude ./hack,./vendor --exclude '**/testdata/**'
        '

    - name: Install tanzu cli
      run: |
        $TANZU_VERSION = "v0.25.0"
        mkdir "C:\Program Files\tanzu"       
        $Env:PATH += ";C:\Program Files\tanzu"
        $TANZU_HOME = "C:\Program Files\tanzu"
        curl -Lo tanzu-framework-windows-amd64.zip https://github.com/vmware-tanzu/tanzu-framework/releases/download/$TANZU_VERSION/tanzu-framework-windows-amd64.zip
        tar -xf tanzu-framework-windows-amd64.zip
        cp "cli\core\$TANZU_VERSION\tanzu-core-windows_amd64.exe" "C:\Program Files\tanzu\tanzu.exe"
        tanzu init
        $Env:TANZU_CLI_NO_INIT = "true"
        tanzu plugin install --local cli all
        tanzu plugin list
        tanzu version
        tanzu plugin repo add -b tanzu-cli-admin-plugins -n admin -p artifacts-admin
        curl -Lo admin-plugins.zip https://github.com/vmware-tanzu/tanzu-framework/releases/download/$TANZU_VERSION/tanzu-framework-plugins-admin-windows-amd64.zip
        tar -xf admin-plugins.zip -C $TANZU_HOME
        tanzu plugin install builder --local $TANZU_HOME/admin-plugins
        tanzu plugin install test --local $TANZU_HOME/admin-plugins
        tanzu plugin list
    - name: Test integration
      run: |
        $Env:PATH += ";C:\Program Files\tanzu"
        $Env:PATH += ";C:\Program Files\kind"
        $env:KUBECONFIG = "C:\Users\runneradmin\.kube\config"
        # $env:PATH
        kubectl config view 
        $env:KUBECONFIG = "C:\Users\runneradmin\.kube\config"
        # strace kubectl version
        # kubectl config current-context
        # kubectl config view 
        # kubectl config --help
        kubectl cluster-info dump
        echo "##[group]Integration Test"
          make integration-test
        echo "##[endgroup]"
      continue-on-error: false
    - name: Delete Gracefully
      run: |
        set -o errexit
        set -o nounset
        set -o pipefail

        echo "##[group]Delete workload"
          printf 'y' | tanzu apps workload delete petclinic
        echo "##[endgroup]"
        echo "##[group]Delete cartographer"
          kapp delete -y -a cartographer -n kube-system
          kubectl delete namespace cartographer-system
        echo "##[endgroup]"
      if: always()
   

  acceptance:
    needs: unitubuntu
    runs-on: ubuntu-latest
    strategy:
      matrix:
        k8s:
        - 1.21.10
        - 1.22.7
        - 1.23.5
    env:
      REGISTRY_NAME: registry.local
      REGISTRY_USERNAME: ruser
      REGISTRY_PASSWORD: rpass
      BUNDLE: registry.local/integration-test/hellojar:source
      TANZU_CLI_NO_INIT: true
      TANZU_HOME: $HOME/tanzu
      OS_ARCH: linux-amd64
      TKG_CUSTOM_IMAGE_REPOSITORY: projects-stg.registry.vmware.com/tkg
    steps:
    - uses: actions/checkout@v3
    - uses: vmware-tanzu/carvel-setup-action@v1
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    - uses: actions/setup-go@v3
      with:
        go-version: 1.19.x
    - name: Download plugin bundle
      uses: actions/download-artifact@v3
      with:
        name: tanzu-apps-plugin.tar.gz
    - name: Generate certs
      run: |
        set -o errexit
        set -o nounset
        set -o pipefail
        CERT_DIR=$(mktemp -d -t certs.XXXX)
        echo "CERT_DIR=$CERT_DIR" >> $GITHUB_ENV
        echo "##[group]Install cfssl"
          go install github.com/cloudflare/cfssl/cmd/cfssl@v1.6.2
          go install github.com/cloudflare/cfssl/cmd/cfssljson@v1.6.2
        echo "##[endgroup]"
        echo "##[group]Generate CA"
          cfssl gencert -initca ./.github/tls/root-csr.json \
            | cfssljson -bare ${CERT_DIR}/root-ca
          cfssl gencert -ca ${CERT_DIR}/root-ca.pem -ca-key ${CERT_DIR}/root-ca-key.pem \
            -config=".github/tls/config.json" \
            -profile="intermediate" ./.github/tls/intermediate-csr.json \
            | cfssljson -bare ${CERT_DIR}/signing-ca
          cat ${CERT_DIR}/signing-ca.pem ${CERT_DIR}/root-ca.pem > ${CERT_DIR}/ca.pem
        echo "##[endgroup]"
        echo "##[group]Install CA"
          # https://ubuntu.com/server/docs/security-trust-store
          sudo apt-get install -y ca-certificates
        echo "##[endgroup]"
        echo "##[group]Generate cert"
          cfssl gencert -ca ${CERT_DIR}/signing-ca.pem -ca-key ${CERT_DIR}/signing-ca-key.pem \
            -config=".github/tls/config.json" \
            -profile="server" \
            -hostname="${REGISTRY_NAME},local-registry" \
            .github/tls/server-csr.json \
            | cfssljson -bare ${CERT_DIR}/server
        echo "##[endgroup]"
    - name: Setup local registry
      run: |
        set -o errexit
        set -o nounset
        set -o pipefail
        # Create password file
        REGISTRY_HTPWD=$(mktemp -d -t htpwd.XXXX)
        docker run \
        --entrypoint htpasswd --platform=linux \
        httpd:2 -Bbn ${REGISTRY_USERNAME} ${REGISTRY_PASSWORD} > ${REGISTRY_HTPWD}/htpasswd
        
        # Run a registry.
        docker run -d \
          --restart=always \
          --name local-registry \
          -v ${CERT_DIR}:/certs \
          -e REGISTRY_HTTP_ADDR=0.0.0.0:443 \
          -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/server.pem \
          -e REGISTRY_HTTP_TLS_KEY=/certs/server-key.pem \
          -p "443:443" \
          registry:2
        # Make the $REGISTRY_NAME -> local-registry
        echo "$(hostname -I | cut -d' ' -f1) $REGISTRY_NAME" | sudo tee -a /etc/hosts
    - name: Install tanzu cli
      run: |
        TANZU_VERSION=$(cat TANZU_VERSION)
        mkdir -p ${TANZU_HOME}
        curl -Lo tanzu-framework.tar.gz https://github.com/vmware-tanzu/tanzu-framework/releases/download/${TANZU_VERSION}/tanzu-framework-linux-amd64.tar.gz
          tar -xzf tanzu-framework.tar.gz -C ${TANZU_HOME}
          sudo mv ${TANZU_HOME}/cli/core/${TANZU_VERSION}/tanzu-core-linux_amd64 /usr/local/bin/tanzu
          chmod +x /usr/local/bin/tanzu
        env
        tanzu init
    - name: Build Version
      run: echo "BUILD_VERSION=${GITHUB_REF/refs\/tags\//}" >> $GITHUB_ENV
      if: startsWith(github.ref, 'refs/tags/')
    - name: Install CLI
      run: |
        set -o errexit
        set -o nounset
        set -o pipefail

        tar -xvf tanzu-apps-plugin.tar.gz
        tanzu plugin install apps --local ./${OS_ARCH} --version v0.0.0-dev
    - name: Install kind
      run: |
        cd $(mktemp -d -t kind.XXXX)
        curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.11.1/kind-$(go env GOHOSTOS)-$(go env GOHOSTARCH)
        chmod +x ./kind
        sudo mv ./kind /usr/local/bin
        cd -
    - name: Create Cluster
      run: |
        set -o errexit
        set -o nounset
        set -o pipefail
     
        # KinD configuration.
        # create a cluster with the local registry enabled in containerd
        cat <<EOF | kind create cluster --config=-
        kind: Cluster
        apiVersion: kind.x-k8s.io/v1alpha4
        containerdConfigPatches:
        - |-
          [plugins."io.containerd.grpc.v1.cri".registry.mirrors."${REGISTRY_NAME}"]
            endpoint = ["https://local-registry"]
        - |-
          [plugins."io.containerd.grpc.v1.cri".registry.configs."local-registry".tls]
            ca_file  = "/etc/docker/certs.d/local-registry/ca.pem"
        nodes:
        - role: control-plane
          image: kindest/node:v${{ matrix.k8s }}
          extraMounts:
          - containerPath: /etc/docker/certs.d/local-registry
            hostPath: ${CERT_DIR}
        EOF

        # connect the registry to the cluster network
        docker network connect kind local-registry

        # Document the local registry
        # https://github.com/kubernetes/enhancements/tree/master/keps/sig-cluster-lifecycle/generic/1755-communicating-a-local-registry
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: local-registry-hosting
          namespace: kube-public
        data:
          localRegistryHosting.v1: |
            host: "localhost"
            help: "https://kind.sigs.k8s.io/docs/user/local-registry/"
        EOF
    - name: Deploy Cartographer
      run: |
        set -o errexit
        set -o nounset
        set -o pipefail

        echo "##[group]Apply cartographer"
          kubectl create namespace cartographer-system
          kapp deploy -y -a cartographer -n kube-system -f ./acceptance/vendor/cartographer/
        echo "##[endgroup]"
    - name: Test CLI commands
      run: |
        set -o errexit
        set -o nounset
        set -o pipefail

        echo "##[group]Integration Test"
          make integration-test
        echo "##[endgroup]"
      continue-on-error: false
    - name: Delete Gracefully
      run: |
        set -o errexit
        set -o nounset
        set -o pipefail

        echo "##[group]Delete workload"
          printf 'y' | tanzu apps workload delete petclinic
        echo "##[endgroup]"
        echo "##[group]Delete cartographer"
          kapp delete -y -a cartographer -n kube-system
          kubectl delete namespace cartographer-system
        echo "##[endgroup]"
      if: always()
    - name: Cleanup cluster
      run: kind delete cluster
      if: always()

  acceptancewindows:
    needs: unitwindows
    runs-on: windows-latest
    strategy:
      matrix:
        k8s:
        - 1.21.10
        - 1.22.7
        - 1.23.5
    env:
      REGISTRY_NAME: registry.local
      REGISTRY_USERNAME: ruser
      REGISTRY_PASSWORD: rpass
      BUNDLE: registry.local/integration-test/hellojar:source
      TANZU_CLI_NO_INIT: true
      TANZU_HOME: $HOME/tanzu
      OS_ARCH: windows-amd64
      TKG_CUSTOM_IMAGE_REPOSITORY: projects-stg.registry.vmware.com/tkg
    # defaults:
    #   run:
    #     shell: wsl-bash {0}
    steps:
    - uses: actions/checkout@v3
    - uses: vmware-tanzu/carvel-setup-action@v1
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    - uses: actions/setup-go@v3
      with:
        go-version: 1.19.x
    - name: Download plugin bundle
      uses: actions/download-artifact@v3
      with:
        name: tanzu-apps-plugin.tar.gz 
    - name: setup Env variables
      run: |
        echo "BUNDLE= registry.local/integration-test/hellojar:source" >> $env:GITHUB_ENV
        # $Env:TANZU_HOME = "C:\Program Files\tanzu"
        # $Env:PATH += ";C:\Program Files\tanzu"
        # $Env:TANZU_CLI_NO_INIT = "true"
        # BUNDLE = "registry.local/integration-test/hellojar:source"
        # $Env:REGISTRY_NAME= "registry-local"
        # $Env:REGISTRY_USERNAME= "ruser"
        # $Env:REGISTRY_PASSWORD= "rpass"
        # $Env:OS_ARCH= "windows-amd64"
        # $Env:TKG_CUSTOM_IMAGE_REPOSITORY= "projects-stg.registry.vmware.com/tkg"
    # - name: Install tanzu cli
    #   run: |
    #     TANZU_VERSION=$(cat TANZU_VERSION)
    #     mkdir -p /root/tanzu
    #     curl -Lo tanzu-framework.tar.gz https://github.com/vmware-tanzu/tanzu-framework/releases/download/${TANZU_VERSION}/tanzu-framework-linux-amd64.tar.gz
    #       tar -xzf tanzu-framework.tar.gz -C /root/tanzu
    #       sudo mv $HOME/tanzu/cli/core/${TANZU_VERSION}/tanzu-core-linux_amd64 /usr/local/bin/tanzu
    #       chmod +x /usr/local/bin/tanzu
    #     env
    #     export ALLOWED_REGISTRY=projects-stg.registry.vmware.com/tkg
    #     tanzu init
    #     tanzu plugin sync
    - name: Install tanzu cli
      run: |
        $TANZU_VERSION = "v0.25.0"
        mkdir "C:\Program Files\tanzu"
        $Env:PATH += ";C:\Program Files\tanzu"
        curl -Lo tanzu-framework-windows-amd64.zip https://github.com/vmware-tanzu/tanzu-framework/releases/download/$TANZU_VERSION/tanzu-framework-windows-amd64.zip
        tar -xf tanzu-framework-windows-amd64.zip
        cp "cli\core\$TANZU_VERSION\tanzu-core-windows_amd64.exe" "C:\Program Files\tanzu\tanzu.exe"
        tanzu init
    - name: Build Version
      run: echo "BUILD_VERSION=${GITHUB_REF/refs\/tags\//}" >> $Env:GITHUB_ENV
      if: startsWith(github.ref, 'refs/tags/')
    - name: Install CLI
      run: |

        tar -xvf tanzu-apps-plugin.tar.gz
        $Env:PATH += ";C:\Program Files\tanzu"
        tanzu plugin install apps --local ./windows-amd64 --version v0.0.0-dev

    - name: Setup WSL
      uses: Vampire/setup-wsl@v1.3.1
      with:
         distribution: Ubuntu-20.04

    # - name: Generate certs
    #   run: |
    #     mkdir "\cert"  
    #     $CERT_DIR= "\cert" 
    #     # Install-Module -Name OpenSSL -Scope CurrentUser -Force
    #     echo "CERT_DIR=$CERT_DIR" >> $env:GITHUB_ENV
    #     # Define certificate name
    #     # Define certificate name

    #     $Certname = "tanzu"
    #     Write-Host "Creating Certifcate $Certname" -ForegroundColor Green
    #     # Create certificate
    #     $Cert = New-SelfSignedCertificate -certstorelocation cert:\localmachine\my -dnsname $Certname -NotAfter (Get-Date).AddDays(1)
    #     Write-Host "Exporting Certificate $Certname to $env:USERPROFILE\$Certname.pfx" -ForegroundColor Green
    #     # Set password to export certificate
    #     $pw = ConvertTo-SecureString -String "Pazzword" -Force -AsPlainText
    #     # Get thumbprint
    #     $thumbprint = $Cert.Thumbprint
    #     # Export certificate
    #     Export-PfxCertificate -cert cert:\localMachine\my\$thumbprint -FilePath $CERT_DIR\$Certname.pfx -Password $pw
    #     # pkcs12 -in $env:USERPROFILE\$Certname.pfx -out privateKey.key -nocerts -nodes
    #     # pkcs12 -in $env:USERPROFILE\$Certname.pfx -out certificate.pem -nokeys -clcerts
    #     # cp certificate.pem $CERT_DIR\server.pem
    #     # cp privateKey.key $CERT_DIR\server-key.pem
    - name: install go
      shell: wsl-bash {0}
      run: |
        VERSION=1.19
        OS=linux
        ARCH=amd64

        cd $HOME
        wget https://storage.googleapis.com/golang/go$VERSION.$OS-$ARCH.tar.gz
        tar -xvf go$VERSION.$OS-$ARCH.tar.gz
        mv go go-$VERSION
        sudo mv go-$VERSION /usr/local

        echo 'export GOROOT=/usr/local/go-1.19' >> $HOME/.bashrc
        echo 'export GOPATH=$HOME/projects/go' >> $HOME/.bashrc
        echo 'export GOBIN=$GOPATH/bin' >> $HOME/.bashrc
        echo 'export PATH=$PATH:$GOROOT/bin' >> $HOME/.bashrc
        echo 'export PATH=$PATH:$HOME/projects/go/bin' >> $HOME/.bashrc
    - name: Generate certs
      shell: wsl-bash {0}
      run: |
        set -o errexit
        set -o nounset
        set -o pipefail
        export REGISTRY_NAME=registry.local
        export BUNDLE=registry.local/integration-test/hellojar:source
        export GOROOT=/usr/local/go-1.19
        export GOPATH=$HOME/projects/go
        export GOBIN=$GOPATH/bin
        export PATH=$PATH:$GOROOT/bin
        export PATH=$PATH:$HOME/projects/go/bin
        sudo apt-get update -y
        sudo apt install gcc -y
        sudo apt-get update -y
        CERT_DIR=$(mktemp -d -t certs.XXXX)
        # echo "CERT_DIR=$CERT_DIR" >> $GITHUB_ENV
        echo "##[group]Install cfssl"
          go install github.com/cloudflare/cfssl/cmd/cfssl@v1.6.2
          go install github.com/cloudflare/cfssl/cmd/cfssljson@v1.6.2
        echo "##[endgroup]"
        echo "##[group]Generate CA"
          cfssl gencert -initca ./.github/tls/root-csr.json \
            | cfssljson -bare ${CERT_DIR}/root-ca
          cfssl gencert -ca ${CERT_DIR}/root-ca.pem -ca-key ${CERT_DIR}/root-ca-key.pem \
            -config=".github/tls/config.json" \
            -profile="intermediate" ./.github/tls/intermediate-csr.json \
            | cfssljson -bare ${CERT_DIR}/signing-ca
          cat ${CERT_DIR}/signing-ca.pem ${CERT_DIR}/root-ca.pem > ${CERT_DIR}/ca.pem
        echo "##[endgroup]"
        echo "##[group]Install CA"
          # https://ubuntu.com/server/docs/security-trust-store
          sudo apt-get install -y ca-certificates
        echo "##[endgroup]"
        echo "##[group]Generate cert"
          cfssl gencert -ca ${CERT_DIR}/signing-ca.pem -ca-key ${CERT_DIR}/signing-ca-key.pem \
            -config=".github/tls/config.json" \
            -profile="server" \
            -hostname="${REGISTRY_NAME},local-registry" \
            .github/tls/server-csr.json \
            | cfssljson -bare ${CERT_DIR}/server
        echo "##[endgroup]"
    - name: install docker
      shell: wsl-bash {0}
      run: |
        sudo apt-get update -y
        sudo apt-get install ca-certificates curl gnupg lsb-release -y
        sudo mkdir -p /etc/apt/keyrings
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
        sudo apt-get update -y
        sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin -y
        # sudo update-alternatives --config iptables
        sudo service docker start
        sudo service docker status
    - name: Setup local registry
      shell: bash
      run: |
        set -o errexit
        set -o nounset
        set -o pipefail
        export REGISTRY_NAME=registry.local
        export REGISTRY_USERNAME=ruser
        export REGISTRY_PASSWORD=rpass
        export BUNDLE=registry.local/integration-test/hellojar:source
        # Create password file
        REGISTRY_HTPWD=$(mktemp -d -t htpwd.XXXX)
        docker run \
        --entrypoint htpasswd --platform=linux \
        httpd:2 -Bbn ${REGISTRY_USERNAME} ${REGISTRY_PASSWORD} > ${REGISTRY_HTPWD}/htpasswd
        
        # Run a registry.
        docker run -d \
          --restart=always \
          --name local-registry \
          -v ${CERT_DIR}:/certs \
          -e REGISTRY_HTTP_ADDR=0.0.0.0:443 \
          -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/server.pem \
          -e REGISTRY_HTTP_TLS_KEY=/certs/server-key.pem \
          -p "443:443" \
          registry:2
        # Make the $REGISTRY_NAME -> local-registry
        echo "$(hostname -I | cut -d' ' -f1) $REGISTRY_NAME" | sudo tee -a /etc/hosts
    # - name: set Experimental as true
    #   run: |
    #     cat 'C:\ProgramData\Docker\Config\daemon.json'
    #     $json = Get-Content 'C:\ProgramData\Docker\Config\daemon.json' | Out-String | ConvertFrom-Json
    #     $json | Add-Member -Type NoteProperty -Name 'experimental' -Value $true
    #     $json | ConvertTo-Json | set-content 'C:\ProgramData\Docker\Config\daemon.json'
    #     cat 'C:\ProgramData\Docker\Config\daemon.json'
    #     restart-service *docker*
        
    # - name: Setup local registry
    #   shell: bash
    #   run: |
    #     docker version
    #     set -o errexit
    #     set -o nounset
    #     set -o pipefail
    #     # Create password file
    #     REGISTRY_HTPWD=$(mktemp -d -t htpwd.XXXX)
    #     REGISTRY_NAME="registry-local"
    #     REGISTRY_USERNAME="ruser"
    #     REGISTRY_PASSWORD="rpass"
    #     docker info
    #     docker version -f '{{.Server.Experimental}}'
    #     # sudo service docker restart
        
    #     # Run a registry.
    #     docker run -d \
    #       --restart=always \
    #       --name local-registry \
    #       -v ${CERT_DIR}:/certs \
    #       -e REGISTRY_HTTP_ADDR=0.0.0.0:443 \
    #       -e REGISTRY_HTTP_TLS_CERTIFICATE=/cert/tanzu.pfx \
    #       -e REGISTRY_HTTP_TLS_KEY=/certs/tanzu.pfx \
    #       -p "443:443" \
    #       registry:2
    #     # Make the $REGISTRY_NAME -> local-registry
    #     echo "$(hostname -I | cut -d' ' -f1) $REGISTRY_NAME" | sudo tee -a /etc/hosts

    # - name: Install kind
    #   run: |
    #     mkdir "C:\Program Files\kind"
    #     $Env:PATH += ";C:\Program Files\kind"
    #     curl.exe -Lo kind-windows-amd64.exe https://kind.sigs.k8s.io/dl/v0.16.0/kind-windows-amd64
    #     Move-Item .\kind-windows-amd64.exe "c:\Program Files\kind\kind.exe"
    # - name: Create Cluster
    #   shell: bash
    #   run: |
    #     set -o errexit
    #     set -o nounset
    #     set -o pipefail
    #     docker version

    #     # CERT_DIR="d/cert"
    #     # KinD configuration.
    #     # create a cluster with the local registry enabled in containerd
    #     cat <<EOF | kind create cluster --config=-
    #     kind: Cluster
    #     apiVersion: kind.x-k8s.io/v1alpha4
    #     containerdConfigPatches:
    #     - |-
    #       [plugins."io.containerd.grpc.v1.cri".registry.mirrors."${REGISTRY_NAME}"]
    #         endpoint = ["https://local-registry"]
    #     - |-
    #       [plugins."io.containerd.grpc.v1.cri".registry.configs."local-registry".tls]
    #         ca_file  = "/etc/docker/certs.d/local-registry/ca.pem"
    #     nodes:
    #     - role: control-plane
    #       image: kindest/node:v${{ matrix.k8s }}
    #       extraMounts:
    #       - containerPath: /etc/docker/certs.d/local-registry
    #         hostPath: ${CERT_DIR}
    #     EOF
 
    #     # connect the registry to the cluster network
    #     docker network connect kind local-registry
 
    #     # Document the local registry
    #     # https://github.com/kubernetes/enhancements/tree/master/keps/sig-cluster-lifecycle/generic/1755-communicating-a-local-registry
    #     cat <<EOF | kubectl apply -f -
    #     apiVersion: v1
    #     kind: ConfigMap
    #     metadata:
    #       name: local-registry-hosting
    #       namespace: kube-public
    #     data:
    #       localRegistryHosting.v1: |
    #         host: "localhost"
    #         help: "https://kind.sigs.k8s.io/docs/user/local-registry/"
    #     EOF
    - name: Install kind
      shell: wsl-bash {0}
      run: |
        cd $(mktemp -d -t kind.XXXX)
        curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.11.1/kind-$(go env GOHOSTOS)-$(go env GOHOSTARCH)
        chmod +x ./kind
        sudo mv ./kind /usr/local/bin
        cd -
    - name: Create Cluster
      shell: wsl-bash {0}
      run: |
        set -o errexit
        set -o nounset
        set -o pipefail

        # KinD configuration.
        # create a cluster with the local registry enabled in containerd
        cat <<EOF | kind create cluster --config=-
        kind: Cluster
        apiVersion: kind.x-k8s.io/v1alpha4
        containerdConfigPatches:
        - |-
          [plugins."io.containerd.grpc.v1.cri".registry.mirrors."${REGISTRY_NAME}"]
            endpoint = ["https://local-registry"]
        - |-
          [plugins."io.containerd.grpc.v1.cri".registry.configs."local-registry".tls]
            ca_file  = "/etc/docker/certs.d/local-registry/ca.pem"
        nodes:
        - role: control-plane
          image: kindest/node:v${{ matrix.k8s }}
          extraMounts:
          - containerPath: /etc/docker/certs.d/local-registry
            hostPath: ${CERT_DIR}
        EOF

        # connect the registry to the cluster network
        docker network connect kind local-registry

        # Document the local registry
        # https://github.com/kubernetes/enhancements/tree/master/keps/sig-cluster-lifecycle/generic/1755-communicating-a-local-registry
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: local-registry-hosting
          namespace: kube-public
        data:
          localRegistryHosting.v1: |
            host: "localhost"
            help: "https://kind.sigs.k8s.io/docs/user/local-registry/"
        EOF
    - name: Deploy Cartographer
      shell: bash
      run: |
        set -o errexit
        set -o nounset
        set -o pipefail
 
        echo "##[group]Apply cartographer"
          kubectl create namespace cartographer-system
          kapp deploy -y -a cartographer -n kube-system -f ./acceptance/vendor/cartographer/
        echo "##[endgroup]"
    - name: Test CLI commands
      run: |
        $Env:PATH += ";C:\Program Files\tanzu"
        $Env:PATH += ";C:\Program Files\kind"
        echo "##[group]Integration Test"
          make integration-test
        echo "##[endgroup]"
      continue-on-error: false
    - name: Delete Gracefully
      run: |
        $Env:PATH += ";C:\Program Files\tanzu"

        echo "##[group]Delete workload"
          printf 'y' | tanzu apps workload delete petclinic
        echo "##[endgroup]"
        echo "##[group]Delete cartographer"
          kapp delete -y -a cartographer -n kube-system
          kubectl delete namespace cartographer-system
        echo "##[endgroup]"
      if: always()
    - name: Cleanup cluster
      run: |
        $Env:PATH += ";C:\Program Files\kind"
        kind delete cluster
      if: always()

  create-release:
    needs:
    - unitubuntu
    - acceptance
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    steps:
    - name: Get the version
      id: get_version
      run: echo ::set-output name=VERSION::${GITHUB_REF/refs\/tags\//}
    - name: Draft release
      id: create_release
      uses: actions/create-release@v1.1.4
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # This token is provided by Actions, you do not need to create your own token
      with:
        tag_name: ${{ github.ref }}
        release_name: Release ${{ steps.get_version.outputs.VERSION }}
        draft: true 
    - name: Create release info files
      run: |
        echo "${{ steps.get_version.outputs.VERSION }}" > RELEASE_INFO_VERSION
        echo "${{ steps.create_release.outputs.upload_url }}" > RELEASE_INFO_UPLOAD_URL
    - name: Upload release files
      uses: actions/upload-artifact@v3
      with:
        name: tanzu-apps-plugin.tar.gz
        path: RELEASE_INFO_*
        retention-days: 1


  release:
    needs:
    - create-release
    if: startsWith(github.ref, 'refs/tags/')
    strategy:
      matrix:
        os-arch: ["", -darwin-amd64, -linux-amd64, -windows-amd64]
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
    - name: Download staged CLI binaries${{ matrix.os-arch }}
      uses: actions/download-artifact@v3
      with:
        name: tanzu-apps-plugin.tar.gz
    - name: Get release info
      run: |
        echo "RELEASE_VERSION=$(cat RELEASE_INFO_VERSION)" >> $GITHUB_ENV
        echo "UPLOAD_URL=$(cat RELEASE_INFO_UPLOAD_URL)" >> $GITHUB_ENV
    - name: Upload CLI release${{ matrix.os-arch }}
      uses: actions/upload-release-asset@v1.0.2
      with:
        upload_url: ${{ env.UPLOAD_URL }}
        asset_path: tanzu-apps-plugin${{ matrix.os-arch }}.tar.gz
        asset_name: tanzu-apps-plugin${{ matrix.os-arch }}-${{ env.RELEASE_VERSION }}.tar.gz
        asset_content_type: application/gzip

